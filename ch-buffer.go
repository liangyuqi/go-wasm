// +build ignore

/*
在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。
带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞

无缓冲通道可以看作是长度永远为 0 的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞：
1、带缓冲通道被填满时，尝试再次发送数据时发生阻塞。
2、带缓冲通道为空时，尝试接收数据时发生阻塞。

tips ：
为什么Go语言对通道要限制长度而不提供无限长度的通道？
我们知道通道（channel）是在两个 goroutine 间通信的桥梁。
使用 goroutine 的代码必然有一方提供数据，一方消费数据。
当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。
因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。
*/

package main

import "fmt"

func main() {

	// 创建一个3个元素缓冲大小的整型通道
	ch := make(chan int, 3)
	// 查看当前通道的大小
	fmt.Println(len(ch))
	// 发送3个整型元素到通道
	ch <- 1
	ch <- 2
	ch <- 3
	// 查看当前通道的大小
	fmt.Println(len(ch))

}
